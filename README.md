# 변형생성문법에 관한 탐구
 요즘 인공지능을 사용한 자연어 처리에 대해 고민중입니다. 특히, 자연어를 기계어로 번역할 수 없는가, 하는 것이 저의 큰 관심사입니다. 그러다 보니 자연스럽게 컴파일러에 관심을 가지게 되었고, 자료를 조사하다 보니 노엄 촘스키의 변형생성문법 이론을 접하게 됐습니다. 본 코드는 문맥 자유 문법을 사용하여, 적당히 실행가능한 것처럼 보이는 C언어 코드를 생성해내는 코드입니다.
 
 물론 본 코드에서 의미론적인 구조를 생성하지는 않습니다. 그렇기 때문에 선언한 적 없는 변수나 함수를 참조하는 등, 실제로 컴파일 가능한 코드를 생성하는 것은 아닙니다.

 프로그램을 실행하면 main함수를 포함하는 랜덤한 c언어 코드를 작성하며, 재귀 호출을 이용한 DFS로 더이상 확장불가능할 때까지 코드를 확장해나갑니다.

 이론상으론 무한히 긴 코드를 작성할 수도 있지만, 수십 번 정도 실행해본 결과 스택 오버플로우가 일어난 적은 없었습니다.

## Files
- exec.py : 공부하면서 참조한 [사이트의 코드](https://ratsgo.github.io/from%20frequency%20to%20semantics/2017/06/29/generate2/)를 조금 확장한 것
- code.py : 직접 작성한 코드 생성 파일

## Generated Code
    double k35t;

    void w(){
    k();
    k = x3531484;
    if('r'){
    if(8){
    }
    k = x62O5188();
    while(66){
    r = p();
    t = us979n;
    _();
    d = 0x1;

    rfsr02071 = g;
    while(hw652495562()){
    }
    _ = qeq2027();
    if(zj = 865 == 339){
    for(y8();'w'; w = c){
    }
    }
    c();
    while(0x4){
    k();
    }
    g();
    while(n++){
    }
    for(k616u();0x57; _s76126395956065L()){
    }
    Oz_m59 = 'u';
    }
    ew34();
    if(0x4){
    z();
    while(a = cjc7r7y()){
    t794706165 = v68();
    }
    u();
    }
    es();
    if('v'){
    }
    d18 = y80333gts();
    }
    nz();
    }

    void p0141210z9(){
    k();
    while('c'){
    _3ac = qd;
    while(s = cv = gi653e9() < k97093()){
    Oa();
    }
    O3();
    if(O){
    }else{
    }
    while(s()){
    v8qO9xm1frh6t();
    }
    c844434 = 6318;
    }
    q = c = 0x19 < p() - v3717u2u878420 < es515() == +32 > u9O1775400138();
    fs9449 = q4387373398464t891392() > 0x52 > j;
    }

    int main(){
    u();
    }